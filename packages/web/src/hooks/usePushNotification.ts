import { useEffect, useState } from "react";
import type { PushSubscription } from "web-push";

import { urlBase64ToUint8Array } from "@/core/util/crypto";
import { pushSubscriptionJsonSchema } from "@/core/web-push/schema";
import {
  getVapidPublicKey,
  sendNotification,
  subscribeUser,
  unsubscribeUser,
} from "@/lib/api/push-notification";

const sstStage = import.meta.env.VITE_SST_STAGE;

const isPermanentStage = sstStage === "stg" || sstStage === "prod";

/**
 * React hook for managing push notifications
 *
 * Provides functionality to check support, register service worker,
 * subscribe/unsubscribe to push notifications, and send test notifications
 */
export function usePushNotification() {
  const [isSupported, setIsSupported] = useState(false);
  const [subscription, setSubscription] = useState<PushSubscription | null>(
    null,
  );
  const [message, setMessage] = useState("");
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    if ("serviceWorker" in navigator && "PushManager" in window) {
      setIsSupported(true);
      registerServiceWorker();
    }
  }, []);

  async function getSubscription() {
    // Use the existing service worker
    const serviceWorkerPath = isPermanentStage
      ? "/prompt-sw.ts"
      : "/dev-sw.js?dev-sw";
    const registration = await navigator.serviceWorker.register(
      serviceWorkerPath,
      {
        scope: "/",
        updateViaCache: "none",
        // In development, the dev-sw generated by vite-plugin-pwa is an ES module
        // and must be registered with `type: "module"`. In permanent stages the
        // compiled service worker is classic, so we only set the option when
        // not in a permanent stage.
        ...(isPermanentStage ? {} : { type: "module" }),
      },
    );
    const sub = await registration.pushManager.getSubscription();
    return sub;
  }

  async function registerServiceWorker() {
    // no subscription exists
    const sub = await getSubscription();
    if (!sub) {
      setSubscription(null);
      return;
    }
    const res = pushSubscriptionJsonSchema.safeParse(sub.toJSON());
    if (!res.success) {
      setError(new Error("Failed to parse subscription"));
      setSubscription(null);
      return;
    }
    const validSubscription = res.data;
    setSubscription(validSubscription);
  }

  async function subscribeToPush() {
    try {
      setError(null);
      const registration = await navigator.serviceWorker.ready;
      const {
        data: { vapidPublicKey },
      } = await getVapidPublicKey();
      const sub = await registration.pushManager.subscribe({
        userVisibleOnly: true,
        // Using the same application server key as in prompt-sw.ts
        applicationServerKey: urlBase64ToUint8Array(vapidPublicKey),
      });

      if (!sub) {
        setError(new Error("Failed to subscribe to push"));
        return false;
      }

      // Use parsePushSubscription to validate and parse the subscription JSON
      const validSubscription = pushSubscriptionJsonSchema.parse(sub.toJSON());
      setSubscription(validSubscription);

      // Send the subscription to the server
      await subscribeUser(validSubscription);
      return true;
    } catch (err) {
      setError(err instanceof Error ? err : new Error(String(err)));
      return false;
    }
  }

  async function unsubscribeFromPush() {
    try {
      setError(null);
      const sub = await getSubscription();
      if (sub) {
        await sub.unsubscribe();
        setSubscription(null);
        await unsubscribeUser();
      }
    } catch (err) {
      setError(err instanceof Error ? err : new Error(String(err)));
    }
  }

  async function sendTestNotification({
    title,
    message,
  }: {
    title: string;
    message: string;
  }) {
    try {
      setError(null);
      if (subscription) {
        await sendNotification({ subscription, title, message });
        setMessage("");
        return true;
      }
      return false;
    } catch (err) {
      setError(err instanceof Error ? err : new Error(String(err)));
      return false;
    }
  }

  return {
    isSupported,
    subscription,
    message,
    setMessage,
    error,

    // Actions
    registerServiceWorker,
    subscribeToPush,
    unsubscribeFromPush,
    sendTestNotification,

    // Helper properties
    isSubscribed: !!subscription,
  };
}
