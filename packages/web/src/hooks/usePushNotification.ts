import { useEffect, useState } from "react";

import { urlBase64ToUint8Array } from "@/core/util/crypto";
import { isDeployedStage } from "@/core/util/stage";
import { PushSubscriptionJsonSchema } from "@/core/web-push/schema";
import {
  getVapidPublicKey,
  sendNotification,
  subscribeUser,
  unsubscribeUser,
} from "@/lib/api/push-notification";

const sstStage = import.meta.env.VITE_SST_STAGE;

const isDeployed = isDeployedStage(sstStage);
/**
 * React hook for managing push notifications
 *
 * Provides functionality to check support, register service worker,
 * subscribe/unsubscribe to push notifications, and send test notifications
 */
export function usePushNotification() {
  const [isSupported, setIsSupported] = useState<boolean | null>(null);
  const [subscription, setSubscription] = useState<PushSubscription | null>(
    null,
  );
  const [message, setMessage] = useState("");
  const [isInitializing, setIsInitializing] = useState(true);
  const [isActionLoading, setIsActionLoading] = useState(false);

  useEffect(() => {
    if (typeof window !== "undefined") {
      if ("serviceWorker" in navigator && "PushManager" in window) {
        setIsSupported(true);
        registerServiceWorker().finally(() => {
          setIsInitializing(false);
        });
      } else {
        setIsSupported(false);
        setIsInitializing(false);
      }
    }
  }, []);

  async function registerServiceWorker() {
    // Use the existing service worker
    const serviceWorkerPath = isDeployed ? "/sw.js" : "/dev-sw.js?dev-sw";
    try {
      const registration = await navigator.serviceWorker.register(
        serviceWorkerPath,
        {
          scope: "/",
          updateViaCache: "none",
          // In development, the dev-sw generated by vite-plugin-pwa is an ES module and must be registered with `type: "module"`
          ...(isDeployed ? {} : { type: "module" }),
        },
      );
      const subscription = await registration.pushManager.getSubscription();
      // no subscription exists
      if (!subscription) {
        setSubscription(null);
        return;
      }
      setSubscription(subscription);
    } catch (error) {
      console.error("Service worker registration failed:", error);
    }
  }

  async function subscribeToPush() {
    setIsActionLoading(true);
    try {
      const registration = await navigator.serviceWorker.ready;
      const {
        data: { vapidPublicKey },
      } = await getVapidPublicKey();
      const sub = await registration.pushManager.subscribe({
        userVisibleOnly: true,
        // Using the same application server key as in sw.ts
        applicationServerKey: urlBase64ToUint8Array(vapidPublicKey),
      });

      setSubscription(sub);
      // Use parsePushSubscription to validate and parse the subscription JSON
      const subJson = PushSubscriptionJsonSchema.parse(sub.toJSON());
      // Send the subscription to the server
      await subscribeUser(subJson);
      return true;
    } catch (error) {
      console.error("Error subscribing to push:", error);
      return false;
    } finally {
      setIsActionLoading(false);
    }
  }

  async function unsubscribeFromPush() {
    setIsActionLoading(true);
    try {
      await subscription?.unsubscribe();
      setSubscription(null);
      await unsubscribeUser();
    } catch (error) {
      console.error("Error unsubscribing from push:", error);
    } finally {
      setIsActionLoading(false);
    }
  }

  async function sendTestNotification({
    title,
    message,
  }: {
    title: string;
    message: string;
  }) {
    setIsActionLoading(true);
    try {
      if (subscription) {
        const subJson = PushSubscriptionJsonSchema.parse(subscription.toJSON());
        await sendNotification({ subscription: subJson, title, message });
        setMessage("");
        return true;
      }
      return false;
    } catch (error) {
      console.error("Error sending test notification:", error);
      return false;
    } finally {
      setIsActionLoading(false);
    }
  }

  return {
    isSupported,
    subscription,
    message,
    setMessage,
    isInitializing,
    isActionLoading,
    // Actions
    registerServiceWorker,
    subscribeToPush,
    unsubscribeFromPush,
    sendTestNotification,

    // Helper properties
    isSubscribed: !!subscription,
  };
}
